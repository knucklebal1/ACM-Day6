# ACM-Day6
1. 最大子段和（洛谷-P1115）
·思路：
求最大连续子序列和，考虑用动态规划搜索答案。设置数组dp存储最大子序列和，如果dp[i-1]（即前一个元素结尾的子数组的最大和）大于0，那么将当前元素a加入到前一个子数组中，得到dp[i]=dp[i-1]+a。如果dp[i-1]小于或等于0，那么当前元素a自己作为一个新的子数组，dp[i]=a。这样确保每个dp[i]都是以第i个元素结尾的子数组的最大和。
·总结：
通过动态规划的方法，可以高效地求解最大子数组和问题，适用于处理包含正数和负数的数组。
2. 采药（洛谷-P1048）
·思路：
可以将题目转化为0-1背包问题。关键在于处理采与不采的分类处理。使用双重循环填充动态规划表dp：外层循环遍历每株草药（i：1~M）；内层循环遍历时间限制（j：1~T）。如果当前草药的时间t[i]超过了当前时间限制j，则不采，（dp[i][j]=dp[i-1][j]）；如果当前草药的时间t[i]没有超过时间限制j，则需要选择是否采（如果不采集，则dp[i][j] = dp[i-1][j]；如果采集，则dp[i][j] = dp[i-1][j-t[i]] + m[i]，表示在剩余时间j-t[i]内采集前i-1株草药的最大价值加上当前草药的价值）。最终选择两者中的较大值作为dp[i][j]。
·总结：
通过动态规划的方法解决了0-1背包问题，可以在有限时间内最大化价值。核心是通过状态转移方程逐步填充动态规划表，得到最优解。
3. 宝物筛选（洛谷-P1776）
·思路：
该题为多重背包问题，特点是每种物品有一定的数量限制，而不是只能选择一次（0-1 背包）或无限次（完全背包）。为了优化，考虑将多重背包转为0-1背包问题。在拆分包时，用二进制优化减少工作量；记录拆分后每个包各自的价值和重量，并记录到数组value和weight里。最后遍历所有拆分包，再对于每个拆分包，从背包总容量W开始倒序遍历（模拟装包情况），用数组dp[j]代表背包重量为j时的最大价值，最后输出dp[W]。
·总结：
通过二进制优化将多重背包问题转化为0-1背包问题，并使用动态规划求解。二进制优化可以减少了物品数量，从而提高效率。核心是通过拆分和状态转移方程逐步求解最优解。
4. 最长公共子序列（洛谷-P1439）
·思路：
求最长公共子序列，可以通过离散化和二分优化提高效率。先进行离散化处理：首先遍历序列a，将每个元素的值a[i]映射到其在序列中的位置i（num[a[i]] = i），将序列a中的值重新编号为1到n；遍历序列b，将每个元素b[i]替换为其在序列a中的离散化值num[b[i]]，这样，问题转化为在序列b中找到一个最长上升子序列。再使用动态规划和二分查找来求解最长上升子序列：遍历序列b，如果b[i]>dp[ans]，说明可以扩展当前的最长上升子序列，dp[++ans]=b[i]；否则，使用lower_bound在dp中找到第一个大于等于b[i]的位置x，并更新dp[x]=b[i]（lower_bound保证dp始终存储最小的可能值）。最终ans即为答案。
·总结：
通过离散化和动态规划的方法高效地求解了最长公共上升子序列问题。离散化将问题转化为在序列b中求解最长上升子序列，再用动态规划和二分查找进一步优化了求解过程。核心是通过维护dp数组来记录最小末尾值，求最优解。


